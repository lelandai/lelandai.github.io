# git worktrees和pyenv：更快地开发Python库
由休·威尔逊 （Huon Wilson） —出版于2020年4月15日
>https://huonw.github.io/blog/2020/04/worktrees-and-pyenv/

内容
语境
顺序开发
同步发展
与工作树并发开发
并行Python依赖项管理
pyenv进行救援
包起来
一次完成一项任务，能够从头到尾完全完成它，然后转移到下一个任务，这是光荣的。听起来不错，但现实却比这更混乱，上下文切换很常见。这样做可能会很烦人且效率低下，但是切换不会意味着任务和同事被延迟。我将git工作树和pyenv（和插件）结合在一起，以减少上下文切换的开销，并在使用Python库时保持开发和协作尽可能顺利。

减轻上下文切换的痛苦，使我可以同时处理许多任务：通常是一个或两个大型功能，其中一些是中型功能，而各种是小型功能。我的一天通常涉及连续几个小时处理较大的功能，然后要么受阻，要么需要一些时间进行下意识的思考，从而承担较小的任务之一。

语境
这篇文章讨论了在StellarGraph库上用于图的机器学习的工作中如何实际使用这些工具。StellarGraph是使用TensorFlow 2，Keras和其他常见数据科学工具构建的Python库。

我们采用相当标准的方法来开发和分发代码，这意味着及时性和协作非常重要：

广泛的演示和文档
支持多个版本的Python（3.6和3.7）
所有更改均通过拉取请求进行（每月70-100次）
要求进行代码审查：没有至少一项批准审查，无法合并拉取请求
还需要进行测试：如果不通过持续集成，包括验证演示，则合并请求请求就无法合并（所有这些过程总共需要花费几分钟的时间）
该StellarGraph队是CSIRO的Data61的项目带来的工程师，科学家的数据，用户体验设计师和研究人员。我最适合这些框的第一个，而作为混合团队的工程师，我的部分角色是成为力量倍增器：优化或以其他方式使代码更可靠，并改善上面（和其他）列出的工具和流程，所有这些这样，那些工程经验较少或研究兴趣更多的人就可以充分利用自己的优势。

这意味着我的一天经常被打破：

查看其他人的拉取请求，这样他们就不必等待批准和反馈了；有时这涉及在本地签出拉取请求的代码以运行它
根据我自己的请求请求响应代码审查，以尽量保持“审查周期”尽可能紧凑；这通常涉及编辑代码以响应
做一些小事来烦人的剪纸
验证对更大或更复杂的功能和错误修复的要求和期望；这通常涉及作为拉取请求草案进行概念验证实施
所有这些都涉及在我的本地计算机上使用存储库的代码，并且它们通常都是很短的任务，从几分钟到几小时不等，而不是像新功能那样需要几天的时间。

除了所有这些代码任务，当我完成功能或错误修复时，我还必须等待一位同事的代码审查：这通常很快（最多一天或两天），但是，如果我当时试图避免上下文切换，但是很长时间不做其他工作。

顺序开发
假设我正在使用功能A，但是随后注意到切纸B可能需要一两分钟来修复，可能是文档中的错字或一个小错误。这类似于上面的第三种情况。

一种方法是仅对功能A的更改进行修复，以使最终的拉取请求和登陆的代码将A和B结合在一起。这是次优的，因为它导致：

较慢的代码审阅：每次审阅都比较大，并且不清楚出于什么目的进行了哪些更改，因此需要进行更多的整理。
不太有用的git历史记录：如果合并的A + B更改出现在git blame调查中，则就像在代码审查中查看它一样，只是作者可能无法回答有关它的问题，因为他们不再记得了（我当然忘了这些排序）详细信息）。
有用的小修补程序的着陆速度较慢：对B的修补程序由于对A的pull请求的冗长审核而陷入困境并被延迟。
更好的方法是在一个单独的分支上并因此在一个单独的拉取请求中执行此工作。使用存储库的单个副本进行此并发工作是令人沮丧的，因为进行修复所需的簿记工作使进行修复的实际工作相形见:：

将我正在进行的工作的状态保存在A的branch上feature/A，这意味着以下两者：
磁盘上文件的实际更改（使用“ WIP”提交或隐藏，请谨慎管理任何相关的临时文件或新文件）
没有直接存储在版本控制中的任何上下文（例如，我在每个文件中进行编辑的位置，或者我下一步打算做的事情）
创建并切换一个新分支bugfix/B，对B进行修复，为其创建拉取请求
通过切换回feature/A分支，然后重新应用/记住步骤1中的任何其他状态，来还原A工作。
实际的修复步骤2比第1或第3步要容易得多，甚至更快，因为第1步或第3步既需要记住有关代码库的内容，也要记住有关git的内容（辛苦！）。

同步发展
如果我有多个并行的源代码副本，则每个列表都可以独立更改，因此列表要简单得多：

从已feature/A签出的目录更改为没有任何正在进行的工作的目录（或创建一个新副本）
创建一个新分支bugfix/B，对B进行修复，为其创建拉取请求
回到目录feature/A，从我停下来的地方开始（包括编辑器中每个文件的确切位置之类的东西）
整个过程只需要步骤2本身，因为记账很少。它并没有直接解决第一个版本中的“记住我打算下一步做什么”的问题，但是确实可以极大地改善它：我发现从“代码工作”心态到“管理”的上下文切换极少。 git”之一，因为整个过程更快，所以忘记或分散注意力的时间就更少了。

与切换分支相比，使用单独的目录还有其他好处：使得增量编译（和其他工具）减少工作量变得更加容易，尽管这不适用于Python 0；而且，我发现找到代码1更容易。

一种实现方法是将存储库多次克隆到单独的目录中，例如...-1，...-2等等：

1
2
3
git clone 'git@github.com:stellargraph/stellargraph.git' stellargraph-1
git clone 'git@github.com:stellargraph/stellargraph.git' stellargraph-2
git clone 'git@github.com:stellargraph/stellargraph.git' stellargraph-3
多年来，我有效地将其用于几个不同的项目。


单个存储库的多个克隆的结构的风格化视图显示它们是相互隔离的。

但是，每个副本都是隔离的，这在实践中会导致一些问题：

它们每个都需要完整的git状态，该状态可能很大。
它们可能会以不一致的状态结束，尤其是关于远程分支的状态：origin/masterinstellargraph-1可能不同于origin/masterin stellargraph-2，取决于何时git pull或何时git fetch运行。
每当我离开一个分支时，都会对“那个分支在哪里”感到困惑，因为默认情况下，每个分支仅存在于创建它的副本中。
与工作树并发开发
更好的方法是使用多个工作树。它们的行为几乎与多个独立克隆相同，不同之处在于它们.git与其所有元数据共享一个目录。因此，每个分支都有权访问所有分支（本地或远程），并且每个副本中每个分支的状态都相同。

可以在单个命令2中创建工作树，类似于git clone：

1
2
3
4
5
cd /path/to/stellargraph-1
# now inside the repository that needs multiple copies

git worktree add ../stellargraph-2 'some-existing-branch'
git worktree add ../stellargraph-3 -b 'some-new-branch'
第一个参数add是新工作树的（兄弟）目录，第二个可选参数是要在其中签出的分支的名称（从此处开始）。这些stellargraph-...目录中的每一个都像普通的git仓库一样，所有常规操作（如创建或切换分支，落实和存储）都很好。


工作树的样式化视图显示它们都共享一个主.git文件夹。

我使用一组固定的工作树，编号从1到5（目前）。

另一种选择（我从未尝试过）是为各个分支提供一个工作树。如果我们要在新分支中启动新功能foo，则系统可能类似于以下内容：

1
2
3
4
5
6
7
8
9
10
git worktree add ../stellargraph-foo -b foo
cd ../stellargraph-foo

# edit code...
git push
# (repeat from 4 until finished)

# finished, so the worktree isn't needed any more
cd ..
rm stellargraph-foo
我在各种项目上都使用过工作树，包括Scala，C ++和Rust。Python带来了一些特殊的挑战。

并行Python依赖项管理
源树的多个副本很棒，但是如果状态混杂在一起，也会导致一些令人困惑的情况。在错误的目录中编辑文件可能很容易，然后不明白为什么它不适用。我知道我花了很多时间来追踪任何位置（功能，文件，目录等）的多个副本的不正确位置的编辑！


依赖管理足够困难，无需一次执行5次

Python常用的依赖关系方法使情况变得更糟：代码需要在正确的虚拟环境中运行，默认情况下，该虚拟环境是单独管理到当前目录的。通常，每个收银台将有它自己的虚拟环境中，如果有一个在精确的集中使用依赖的差异，让每个副本准确安装其上盘版StellarGraph的使用--editable。

终端中的序列可能看起来像：

1
2
3
4
5
6
7
8
9
cd .../stellargraph-1
. venv/bin/activate
# do work, like running tests:
pytest tests/

# finished there, let's move
cd ../stellargraph-2
# run tests again
pytest tests/
不幸的是，我在这里犯了一个错误：第pytest9行的运行是使用stellargraph-1工作stellargraph-2树中的虚拟环境运行的，无法正确反映源树的状态。我需要在第7行. venv/bin/activate之后cd使用中的venv目录再次运行stellargraph-2。

pyenv进行救援
我使用pyenv和pyenv-virtualenv解决了这个问题。我没有在每个工作树中（例如在venv子目录中）创建虚拟环境，而是为每个工作树创建了一个pyenv虚拟环境，并使用进行了关联pyenv local。例如，对于工作stellargraph-1树，我运行了类似的内容：

1
2
pyenv virtualenv 3.6.10 'stellargraph-1'
pyenv local 'stellargraph-1'
完成此操作后，在工作树中的任何位置使用python或pip（如pip install --editable .或pytest）的任何命令都stellargraph-1将自动使用stellargraph-1虚拟环境3：我不需要手动激活或停用虚拟环境，从而消除了主要的人为错误。

使用pyenv进行版本管理还有其他好处：

pyenv-jupyter-kernel允许使用Jupyter自动注册每个虚拟环境，从而可以轻松地在笔记本中测试功能和错误修复，更重要的是，可以在StellarGraph的演示中进行工作。
可以轻松地为不同版本的Python创建虚拟环境（替换3.6.10为3.7.7）。例如，我还stellargraph-1-3_7必须在工作stellargraph-1树中与Python 3.7进行测试/比较（我不将它们与pyenv local，一起使用pyenv shell，这确实需要手动激活和停用）。
包起来
我使用git工作树来拥有共享git元数据的StellarGraph Python库的并行副本，并使用pyenv和pyenv-virtualenv来管理每个Python虚拟环境。这减少了切换上下文的开销，因此通过将小的修订放入大型功能的空白中，使我更容易进行更多的工作并有效地进行协作。

分享到  推特  Facebook
切换分支将更新磁盘上文件的内容，这看起来像是对那些文件的修改，即使在步骤3中还原原始文件时所有这些更改都被撤消了，监视修改以减少工作量的工具也将被混淆。 “切换，…，切换回去”，虚假地做更多的工作：单独的目录完全避免了这种情况

许多Python项目（包括StellarGraph）不需要担心刷新/重建与源树相关联的状态，因为它们通常没有任何编译的工件或与分支相关联的其他生成状态。该代码直接从源文件运行，而无需任何编译或预处理。

在诸如Scala或C ++之类的编译语言中，我发现此好处更为重要：当构建可以递增时，构建会快得多，只需更新与我实际更改的（少量）源文件相关的工件即可。如果切换分支然后又虚假地修改-然后-未修改很多文件（或具有很多从属的文件），那么在没有任何分支切换的情况下，这样做之后的第一个构建可能比增量构建慢得多。 ↩

我总是忘了在完成分支后删除分支，因此最终我遇到了数十个（或数百个…）与关闭和合并请求合并的本地分支。这些会干扰制表符的完成，需要我记住相当大的名字git checkout ...。我发现更容易记住少数几个签出中包含相关代码，并且即使我忘记了，也可以使用蛮力检查每个副本的方法（向前跳过，使用，这甚至更快git worktree list）。在某些方面，这种好处是在治疗症状，而不是疾病……但它对我有用。 ↩

我通常在Emacs中通过magit使用git ，这些创建命令位于% b或% c在magit状态缓冲区中，并且在工作树之间跳转是% g（相关文档）。 ↩

在虚拟环境中使用pyenv非常适合在多个单独的库/代码库上工作，即使没有多个副本也是如此。过程完全相同：pyenv virtualenv ...初始化环境，以及pyenv local将目录与虚拟环境关联。 ↩

